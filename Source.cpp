#include <string>
#include <SDL.h>


#include "Utilities.h"

#include <stdio.h>
#include <string>
#include <iostream>
#include <algorithm>
#include <vector> 

using namespace std;

//Screen dimension constants
constexpr static const int32_t SCREEN_WIDTH = 640;
constexpr static const int32_t SCREEN_HEIGHT = 480;
constexpr static const int32_t RENDER_WIDTH = SCREEN_WIDTH;
constexpr static const int32_t RENDER_HEIGHT = SCREEN_HEIGHT;

constexpr static const char* g_kWindowTitle = "Sand";



//function prototypes
inline void setPosition(int32_t* board, int32_t x, int32_t y, int32_t v);

inline int32_t getPosition(int32_t* board, int32_t x, int32_t y);

SDL_Window* CreateCenteredWindow();

SDL_Renderer* CreateRenderer(SDL_Window* pWindow, bool hardwareAccelerated);

SDL_Texture* CreateBackBufferTexture(SDL_Renderer* pRenderer);

void Shutdown(SDL_Window** ppWindow, SDL_Renderer** ppRenderer, SDL_Texture** ppTexture);

int32_t Startup(SDL_Window** ppWindow, SDL_Renderer** ppRenderer, SDL_Texture** ppTexture);

bool ProcessInput();

void  runSim(int32_t* board);

void emptyBoard(int32_t* board);

void setBorder(int32_t* board);

int32_t Render(SDL_Window* pWindow, SDL_Renderer* pRenderer, SDL_Texture* pTexture, int32_t* board);




SDL_Window* CreateCenteredWindow()
{
    // Get current device's Display Mode to calculate window position
    SDL_DisplayMode DM;
    SDL_GetCurrentDisplayMode(0, &DM);

    // Calculate where the upper-left corner of a centered window will be
    const int32_t x = DM.w / 2 - SCREEN_WIDTH / 2;
    const int32_t y = DM.h / 2 - SCREEN_HEIGHT / 2;

    // Create the SDL window
    SDL_Window* pWindow = SDL_CreateWindow(g_kWindowTitle, x, y, SCREEN_WIDTH, SCREEN_HEIGHT,
        SDL_WINDOW_ALLOW_HIGHDPI);

    if (e(!pWindow, "Failed to create Window\n"));

    return pWindow;
}

// Create SDL renderer and configure whether or not to use Hardware Acceleration
SDL_Renderer* CreateRenderer(SDL_Window* pWindow, bool hardwareAccelerated)
{
    if (hardwareAccelerated)
        return SDL_CreateRenderer(pWindow, -1, SDL_RENDERER_ACCELERATED);
    else
        return SDL_CreateRenderer(pWindow, -1, SDL_RENDERER_SOFTWARE);
}

// Create an SDL Texture to use as a "back buffer"
SDL_Texture* CreateBackBufferTexture(SDL_Renderer* pRenderer)
{
    SDL_Texture* pTexture = SDL_CreateTexture(pRenderer, SDL_PIXELFORMAT_ARGB8888,
        SDL_TEXTUREACCESS_STREAMING, RENDER_WIDTH, RENDER_HEIGHT);

    if (e(!pTexture, "Failed to create Back Buffer Texture\n"));

    return pTexture;
}

// Free resources 
void Shutdown(SDL_Window** ppWindow, SDL_Renderer** ppRenderer, SDL_Texture** ppTexture)
{
    // Free the Back Buffer
    if (ppTexture)
    {
        SDL_DestroyTexture(*ppTexture);
        *ppTexture = nullptr;
    }

    // Free the SDL renderer
    if (ppRenderer)
    {
        SDL_DestroyRenderer(*ppRenderer);
        *ppRenderer = nullptr;
    }

    // Free the SDL window
    if (ppWindow)
    {
        SDL_DestroyWindow(*ppWindow);
        *ppWindow = nullptr;
    }
}

// Initialize SDL Components 
int32_t Startup(SDL_Window** ppWindow, SDL_Renderer** ppRenderer, SDL_Texture** ppTexture)
{
    SDL_Init(SDL_INIT_VIDEO);

    if (e(!ppWindow, "Potiner to Window* was null\n")) return -1;

    *ppWindow = CreateCenteredWindow();

    if (e(!*ppWindow, "No Window. Aborting..."))
    {
        Shutdown(ppWindow, ppRenderer, ppTexture);

        return -1;
    }

    if (e(!ppRenderer, "Pointer to Renderer* was null\n")) return -1;

    *ppRenderer = CreateRenderer(*ppWindow, true);

    if (e(!ppRenderer, "No Renderer. Aborting..."))
    {
        Shutdown(ppWindow, ppRenderer, ppTexture);

        return -1;
    }

    if (e(!ppTexture, "Pointer to Texture* was null\n")) return -1;

    *ppTexture = CreateBackBufferTexture(*ppRenderer);

    if (e(!*ppTexture, "No back buffer Texture. Aborting..."))
    {
        Shutdown(ppWindow, ppRenderer, ppTexture);

        return -1;
    }

    return 0;
}


// Call this once during each render loop in order to determine when the user wishes to terminate the program
bool ProcessInput()
{
    // Return this value to tell the caller whether or not it should continue rendering
    // We will terminate the application if any key is pressed
    bool keepRenderLoopRunning = true;

    // Events are generated by SDL whenever something occurs system-wide
    // We are only interested in keyboard events and when the user closes the window
    // We will terminate the application if a key is pressed or if the window is manually closed
    SDL_Event event;

    // Process all events and return whether or not to quit
    while (SDL_PollEvent(&event))
    {
        // Handle relevant SDL events
        switch (event.type)
        {
            // Terminate application if a key is pressed or if the user closes the window
        case SDL_KEYDOWN:
        case SDL_QUIT:
            keepRenderLoopRunning = false;
        }
    }

    // Let the caller know if it should continue rendering, otherwise terminate
    return keepRenderLoopRunning;
}


void runSim(int32_t* board)
{
    int32_t direction;
    int32_t hold;
    int32_t size = SCREEN_WIDTH * SCREEN_HEIGHT;
    /*int32_t* temp = new int[size];
    
    for (int32_t p = 0; p < size; p++) // copy old array into temp array
    {
        temp[p] = board[p];
    }*/
    for (int32_t y = SCREEN_HEIGHT - 2; y > 1; y--)
    {
        for (int32_t x = 2; x < SCREEN_WIDTH - 1; x++)
        {
            if (getPosition(board, x, y) == 1) //if it's sand
            {
                if (getPosition(board, x, y + 1) == 0) //spot below is empty, swap the values
                {
                    hold = getPosition(board,x, y);
                    setPosition(board, x, y, getPosition(board, x, y + 1));
                    setPosition(board, x, y + 1, hold);
                    continue;
                }
                direction = FastRand() % 2;
                if (direction == 0)
                {
                    direction = -1;
                }
                if (getPosition(board, x - direction, y + 1) == 0) //spot diagonal is empty, swap the values
                {
                    hold = getPosition(board, x, y);
                    setPosition(board, x, y, getPosition(board, x - direction, y + 1));
                    setPosition(board, x - direction, y + 1, hold);
                    if (direction == 1)
                    {
                        x++;
                    }
                    continue;
                }
                if (getPosition(board, x + direction, y + 1) == 0) //spot diagonal is empty, swap the values
                {
                    hold = getPosition(board, x, y);
                    setPosition(board, x, y, getPosition(board, x + direction, y + 1));
                    setPosition(board, x + direction, y + 1, hold);
                    if (direction == 1)
                    {
                        x++;
                    }
                    continue;
                }
            }
        }
    }
}

void emptyBoard(int32_t* board)
{
    for (int32_t i = 0; i < SCREEN_HEIGHT*SCREEN_WIDTH; i++)
    {
        //cout << "i = " << i << endl;
        board[i] = 0;
    }
}

void setBorder(int32_t* board)
{
    for (int32_t y = 0; y < SCREEN_HEIGHT; y++)
    {
        setPosition(board, 0, y, -1);
        setPosition(board,1, y, -1);
        setPosition(board,SCREEN_WIDTH, y, -1);
        setPosition(board,SCREEN_WIDTH - 1, y, -1);
    }
    for (int32_t x = 0; x < SCREEN_WIDTH; x++)
    {
        setPosition(board,x, 0, -1);
        setPosition(board,x, 1, -1);
        setPosition(board,x, SCREEN_HEIGHT, -1);
        setPosition(board,x, SCREEN_HEIGHT - 1, -1);
    }
}

inline void setPosition(int32_t* board, int32_t x, int32_t y, int32_t v)
{
    board[x + y * SCREEN_WIDTH] = v;
}

inline int32_t getPosition(int32_t* board, int32_t x, int32_t y)
{
    return board[x + y * SCREEN_WIDTH];
}


// Call this within every render loop
// Fills screen with randomly generated colored pixels
int32_t Render(SDL_Window* pWindow, SDL_Renderer* pRenderer, SDL_Texture* pTexture, int32_t* board)
{
    // The Back Buffer texture may be stored with an extra bit of width (pitch) on the video card in order to properly
    // align it in VRAM should the width not lie on the correct memory boundary (usually four bytes).
    int32_t pitch = 0;

    // This will hold a pointer to the memory position in VRAM where our Back Buffer texture lies
    uint32_t* pPixelBuffer = nullptr;

    // Lock the memory in order to write our Back Buffer image to it
    if (!SDL_LockTexture(pTexture, NULL, (void**)&pPixelBuffer, &pitch))
    {
        // The pitch of the Back Buffer texture in VRAM must be divided by four bytes
        // as it will always be a multiple of four
        pitch /= sizeof(uint32_t);

        // Fill texture with randomly colored pixels
        for (uint32_t i = 0; i < SCREEN_WIDTH * SCREEN_HEIGHT; ++i)
            switch (board[i])
            {
            case 1:
                pPixelBuffer[i] = ARGB(144, 144, 144, 255);
                //SDL_SetRenderDrawColor(gRenderer, 144, 144, 144, 255);
                //SDL_RenderDrawPoint(gRenderer, x, y);
                break;
            case 0:
                pPixelBuffer[i] = ARGB(255, 255, 255, 255);
                break;
            case -1:
                pPixelBuffer[i] = ARGB(0, 0, 0, 255);
                //SDL_SetRenderDrawColor(gRenderer, 0, 0, 0, 255);
                //SDL_RenderDrawPoint(gRenderer, x, y);
                break;
            }
        // Unlock the texture in VRAM to let the GPU know we are done writing to it
        SDL_UnlockTexture(pTexture);

        // Copy our texture in VRAM to the display framebuffer in VRAM
        SDL_RenderCopy(pRenderer, pTexture, NULL, NULL);

        // Copy the VRAM framebuffer to the display
        SDL_RenderPresent(pRenderer);

        return 0;
    }
    else
        return -1;
}




int main(int argc, char* args[])
{
    int32_t* board = new int[SCREEN_HEIGHT*SCREEN_WIDTH];
    int32_t size = SCREEN_HEIGHT * SCREEN_WIDTH;

    SDL_Window* pWindow = nullptr;
    SDL_Renderer* pRenderer = nullptr;
    SDL_Texture* pTexture = nullptr;

    if (e(Startup(&pWindow, &pRenderer, &pTexture), "Startup Failed. Aborting...\n"))
    {
        Shutdown(&pWindow, &pRenderer, &pTexture);
        return -1;
    }
    
    emptyBoard(board);
    setBorder(board);
    cout << board[0] << endl;
    cout << board[4] << endl;
    bool running = true;
    setPosition(board, SCREEN_WIDTH / 2, 4, 1);
    while (running)
    {
            if (e(Render(pWindow, pRenderer, pTexture, board), "Render failed\n")) break;
            running = ProcessInput();
            runSim(board);
            setPosition(board, SCREEN_WIDTH / 2, 4, 1);

    }
    return 0;
}